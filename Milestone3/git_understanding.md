Pull Requests (PRs) are important because they allow team members to review each other’s code before it gets merged into the main branch. This helps catch bugs, maintain consistent code quality, and make sure everyone is aware of the changes being made. It also creates a space for feedback, discussion, and collaboration.
A good PR is clear and focused on one specific change or feature. It should have a meaningful title, a short description explaining what was done and why, and link to any related issue if needed. A well-structured PR makes it easier for reviewers to understand the purpose of the change and give useful feedback.
I looked at a few open-source PRs and saw how both contributors and bots were involved in the discussion. People were giving feedback, pointing out issues or conflicts, and asking questions before anything got merged. I also noticed that tests were automatically run to make sure the changes didn’t break anything. It showed me how open-source projects maintain quality by using PRs as a checkpoint for review, testing, and teamwork.
comment added.

Staging is like preparing your work — you’re telling Git which specific changes you want to include in your next commit. Committing is the actual step that records those changes into the repository history. Until you commit, staged files are just set aside, not saved.
Git separates staging and committing to give developers more control. Sometimes you don’t want to commit everything you've changed — maybe you're working on two different features or fixed a bug while doing something else. Staging lets you choose exactly what goes into the commit so your history stays clean and organized.
This is useful when you're in the middle of something but want to save part of your progress. You might also use staging to carefully review what you're about to commit, especially in team projects where every commit matters. It also helps when breaking big changes into smaller, focused commits.

Pushing directly to main can be risky because it bypasses the opportunity to review or test changes before they go live. If there's a mistake, it can immediately affect everyone pulling from the main branch, especially in a team setting. It also increases the chances of accidentally introducing bugs or breaking the codebase.
Branches let you isolate your work so it can be reviewed separately before merging. This means teammates can give feedback, suggest changes, and even test your work without touching the main branch. It keeps the main branch stable and avoids messy surprises.
If two people make changes to the same file on different branches, Git will try to merge them later — but if the changes are on the same lines or conflict in some way, a merge conflict happens. In that case, someone will need to manually decide which changes to keep. Using branches helps organize and reduce these conflicts by keeping work separated until it's ready to be combined.

While experimenting with these Git commands, I learned how each one plays an important role in managing code within a team. The git checkout main -- <file> command was useful for restoring just one file from the main branch without touching anything else — a good way to undo specific changes. git cherry-pick let me apply a single commit from another branch to main, which is great when you only want to bring in one fix or feature without merging the entire branch. I used git log to view the full commit history, which helps track how the project has evolved over time. Finally, git blame showed who last edited each line in a file, which is incredibly useful for debugging or understanding why a line of code exists. I was surprised by how powerful and detailed git blame was, and how easy cherry-pick made it to isolate and reuse commits. These are definitely commands I can see myself using regularly in long-term projects with multiple developers.

I tested out git bisect and found it really useful for tracking down the exact commit where a bug was introduced. It works by using binary search — you mark one commit as “good” and another as “bad,” and Git walks you through the middle commits until it finds the one that caused the issue. In a real-world project, I’d use this when I know something broke but I’m not sure when or why, especially in a big codebase with lots of commits. Compared to manually checking each commit, git bisect is way faster and more efficient. It takes the guesswork out of debugging and helps isolate the problem without having to scan through the whole history yourself.